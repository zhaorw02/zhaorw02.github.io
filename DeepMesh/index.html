<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="description" content="DeepMesh: Auto-Regressive Artist-mesh Creation with Reinforcement Learning">
    <meta name="keywords" content="3D Mesh Generation, DPO, LLM, Point Cloud">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>DeepMesh</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">

    <link rel="stylesheet" href="./static/css/bulma.min.css">
    <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
    <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
    <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
    <link rel="stylesheet" href="./static/css/index.css">

    <style>
       
        .results-carousel {
            display: flex;
            flex-wrap: wrap;         
            justify-content: center; 
            align-items: flex-start; 
            gap: 20px;              
           
            
          }
          .caption-text {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

		.render_wrapper {
            position: relative;
            height: 300px;
            
            
        }
   
		.render_div {
			position: absolute;
			top: 0;
			left: 0;
		}

       
       
    </style>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script defer src="./static/js/fontawesome.all.min.js"></script>
    <script src="./static/js/bulma-carousel.min.js"></script>
    <script src="./static/js/bulma-slider.min.js"></script>
    <script src="./static/js/index.js"></script>
    <!-- model viewer -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.1.1/model-viewer.min.js"></script>
    
</head>

<body>

    <section class="hero">
        <div class="hero-body">
            <div class="container is-max-desktop">
                <div class="columns is-centered">
                    <div class="column has-text-centered">
                        <h1 class="title is-1 publication-title">DeepMesh: Auto-Regressive Artist-mesh Creation with Reinforcement Learning</h1>    
                        <div class="is-size-5 publication-authors">
                            <!-- Paper authors -->
                            <span class="author-block">
                                <div class="is-size-8 publication-authors">
                                  <span class="author-block">
                                    <a href="https://zhaorw02.github.io/">Ruowen Zhao</a><sup>*1,3</sup>,
                                  <span class="author-block">
                                      <a href="https://jamesyjl.github.io/">Junliang Ye</a><sup>*1,3</sup>,
                                  <span class="author-block">
                                    <a href="https://thuwzy.github.io/">Zhengyi Wang</a><sup>*1,3</sup>,
                                </div>
                                <div class="is-size-8 publication-authors">
                                  <span class="author-block">
                                      Guangce Liu<sup>3</sup>,
                                  <span class="author-block">
                                    <a href="https://buaacyw.github.io/">Yiwen Chen</a><sup>2</sup>,
                                  <span class="author-block">
                                     <a href="https://yikaiw.github.io/">Yikai Wang</a><sup>1</sup>,
                                  <span class="author-block">
                                    <a href="https://ml.cs.tsinghua.edu.cn/~jun/index.shtml">Jun Zhu</a><sup>1,3</sup>
                                  </span>
                                </div>
                            <div class="is-size-8 publication-authors">
                                <sup>1</sup>Tsinghua University,
                                <sup>2</sup>Nanyang Technological University, <sup>3</sup>ShengShu
                            </div>
                            (*Equal Contribution)
                            
                        </div>
                            <div class="column has-text-centered">
                                <div class="publication-links">

                                    <span class="link-block">
                                        <a href="https://arxiv.org/abs/2503.15265" class="external-link button is-normal is-rounded is-dark" href="">
                                            <span class="icon">
                                                <i class="ai ai-arxiv"></i>
                                            </span>
                                            <span>arXiv</span>
                                        </a>
                                    </span>
                                    <!-- Github Link. -->
                                    <span class="link-block">
                                        <a href="https://github.com/zhaorw02/DeepMesh" class="external-link button is-normal is-rounded is-dark">
                                            <span class="icon">
                                                <i class="fab fa-github"></i>
                                            </span>
                                            <span>Code</span>
                                        </a>
                                    </span>
                                    <span class="link-block">
                                        <a href="https://huggingface.co/zzzrw/DeepMesh/tree/main" class="external-link button is-normal is-rounded is-dark">
                                            <span class="icon">
                                                <svg class="svg-inline--fa fa-database fa-w-14" aria-hidden="true" focusable="false" data-prefix="fa" data-icon="database" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 73.143v45.714C448 159.143 347.667 192 224 192S0 159.143 0 118.857V73.143C0 32.857 100.333 0 224 0s224 32.857 224 73.143zM448 176v102.857C448 319.143 347.667 352 224 352S0 319.143 0 278.857V176c48.125 33.143 136.208 48.572 224 48.572S399.874 209.143 448 176zm0 160v102.857C448 479.143 347.667 512 224 512S0 479.143 0 438.857V336c48.125 33.143 136.208 48.572 224 48.572S399.874 369.143 448 336z"></path></svg>
                                            </span>
                                            <span>Checkpoint</span>
                                        </a>
                                    </span>
                                    <!-- YouTube Link. -->
                                    <span class="link-block">
                                        <a href="https://www.youtube.com/watch?v=6grL7bSbQ2w" class="external-link button is-normal is-rounded is-dark">
                                            <span class="icon">
                                                <i class="fab fa-youtube"></i>
                                            </span>
                                            <span>Youtube</span>
                                        </a>
                                    </span>
                                </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>


    <section class="hero is-light is-small">
        <h2 class="title is-3" style="text-align: center;"> Demo Video </h2>
        <div class="columns is-centered has-text-centered">
          
          <div class="column is-full-width">
            <div class="column">
              <video id="teaser" autoplay muted loop playsinline width="1350" height="600">
                <source src="demo.mp4" type="video/mp4">
              </video>
              <p>
                <strong>All of the meshes above are generated by DeepMesh.</strong> 
                DeepMesh can generate high-quality meshes conditioned on the given point cloud by auto-regressive transformer.
              </p>
            </div>
          </div>
        </div>
        <div>
            <h2 class="title is-3" style="text-align: center;"> Point-cloud Conditioned Mesh Generation </h2>
            <div class="container", id="render-container">
                <p style="text-align: center;">
                    DeepMesh creates the mesh on the right from the point cloud on the left. 
                    Drag with the left mouse button to change the view, right mouse button to move the mesh.
                </p>
                <div id="results-carousel" class=" carousel results-carousel ">
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_001" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_001" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_002" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_002" class="render_div"></div>
                    </div>
                </div>
                <div id="results-carousel" class=" carousel results-carousel ">
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_003" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_003" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_004" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_004" class="render_div"></div>
                    </div>
                </div>
    
            </div>
        </div>
        
    </section>
    <script>
        window.addEventListener("DOMContentLoaded", function() {
          var video = document.getElementById("teaser");
          video.playbackRate = 0.8; 
        });
      </script>
    
    <section class="hero is-light is-small">
        <div class="columns is-centered has-text-centered">
          
            <div class="column is-full-width">
              <h2 class="title is-3" style="text-align: center;">Animation of Mesh Generation</h2>
                <p style="text-align: center;">
                    The following video shows an animation of the mesh generation process. We generate all faces of mesh sequentially.
                </p>
              <div class="column">
                
                  <video id="animation" autoplay muted loop playsinline width="1350" height="600">
                  <source src="output.mp4" type="video/mp4">
                </video>
              </div>
            </div>
          </div>
    </section>
    <script>
        window.addEventListener("DOMContentLoaded", function() {
          var video = document.getElementById("animation");
          video.playbackRate = 0.75; // 0.5 倍速播放
        });
      </script>


   <!-- Paper abstract -->
    <section class="hero is-light is-small">
        <div class="container is-max-desktop">
            <h2 class="title is-3" style="text-align: center;">Abstract</h2>
            <div class="content has-text-justified">
                <p>
                Triangle meshes play a crucial role in 3D applications for efficient manipulation and rendering. While auto-regressive methods generate structured meshes by predicting discrete vertex tokens, 
                they are often constrained by limited face counts and mesh incompleteness. To address these challenges, we propose DeepMesh, a framework that optimizes mesh generation through two key innovations: 
                (1) an efficient pre-training strategy incorporating a novel tokenization algorithm, along with improvements in data curation and processing, and (2) the introduction of Reinforcement Learning (RL) 
                into 3D mesh generation to achieve human preference alignment via Direct Preference Optimization (DPO). We design a scoring standard that combines human evaluation with 3D metrics to collect preference
                pairs for DPO, ensuring both visual appeal and geometric accuracy. Conditioned on point clouds and images, DeepMesh generates meshes with intricate details and precise topology, outperforming state-of-the-art methods in both precision and quality.
                </p>
            </div>
            <h2 class="title is-3" style="text-align: center;">Method</h2>
            <img width="1450px" src="./static/images/framework.png" alt="MY ALT TEXT"/> 
            <div class="content has-text-justified">
                <p>
                <strong>Fig. the pipeline of DeepMesh</strong>. DeepMesh is an auto-regressive transformer composed of both self-attention and cross-attention layers. 
                The model is pre-trained on discrete mesh tokens generated by our improved tokenization algorithm. To further enhance the quality of results, we propose
                a scoring standard that combines 3D metrics with human evaluation. With this standard, we annotate 5,000 preference pairs and then post-train the model with 
                DPO to align its outputs with human preferences.
                </p>
            </div>
        </div>
    </section>
   
    
    
    
   
    

    <section class="section" id="BibTeX">
        <div class="container is-max-desktop content">
            <h2 class="title is-4">BibTeX</h2>
            <pre>
                <code>
                    @misc{zhao2025deepmeshautoregressiveartistmeshcreation,
                        title={DeepMesh: Auto-Regressive Artist-mesh Creation with Reinforcement Learning}, 
                        author={Ruowen Zhao and Junliang Ye and Zhengyi Wang and Guangce Liu and Yiwen Chen and Yikai Wang and Jun Zhu},
                        year={2025},
                        eprint={2503.15265},
                        archivePrefix={arXiv},
                        primaryClass={cs.CV},
                        url={https://arxiv.org/abs/2503.15265}, 
                  }
                </code>
            </pre>
        </div>
    </section>

    
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

    import { PLYLoader } from './js/PLYLoader.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    


    let div_to_scene = {};
    

    let items = [
        "001",
        "002",
        "003",
        "004",
        "005",
        "006",
        "007",
        "008",
        "009",
        "010",
        "011",
        "012",
        "013",
        "014",
        "015",
        "016",
        "017",
        "018",
        "019",
        "020"
       
        

    ]
   
    let currentPage = 1;  
    let itemsPerPage = 4; 
    let totalPages = Math.ceil(items.length / itemsPerPage) || 1; 

    for (let item of items) {
        let key = `images_${item}`;
        div_to_scene[key] = { geo: null, color: null };
        key = `pc_cond_${item}`;
        div_to_scene[key] = { geo: null, color: null };
        key = `pc_${item}`;
        div_to_scene[key] = { geo: null, color: null };
    }



    let mouse_button_down = false;
    let list_of_orbit_controls = []
    let style_camera = null;
    let render_colors = true;
    let style_id = "0"

    function setup_camera(div_name){
        console.log(div_name)
        let container = document.getElementById(div_name);
        let width = container.parentElement.clientWidth;
        let height = container.parentElement.clientHeight;
        let camera = new THREE.PerspectiveCamera( 52, width / height, 0.1, 50 );

        
        
        //let camera_init_position = new THREE.Vector3( 2.25, 1.525, -3.75 );
        let camera_init_position = new THREE.Vector3( 2.25, 1.525, 3.75 );
        
        
        camera_init_position = camera_init_position.multiplyScalar(0.5)
        camera.position.set(camera_init_position.x, camera_init_position.y, camera_init_position.z);
        return camera;
    }
    

    function setup_render_divs(div_name, mesh_path){
        let camera = setup_camera(div_name)
        let orbit_control = create_render_div(camera, div_name, mesh_path)
        list_of_orbit_controls.push(orbit_control)
    }

    function setup_render_divs_pc(div_name, mesh_path){
        let camera = setup_camera(div_name)
        let orbit_control = create_point_cloud_div(camera, div_name, mesh_path)
        list_of_orbit_controls.push(orbit_control)
    }

    function clear_scenes() {
        for (let div_id in div_to_scene) {
            let container = document.getElementById(div_id);
            if (container) {
                container.innerHTML = ''; 
            }
        }
        list_of_orbit_controls = []; 
    }
    
    function render_page(page) {
        clear_scenes(); 
        let startIdx = (page - 1) * itemsPerPage; 
        let endIdx = Math.min(startIdx + itemsPerPage, items.length);
    
        for (let i = 0; i < itemsPerPage; i++) {
            let itemIdx = startIdx + i;
            if (itemIdx >= items.length) break; 
    
            let item = items[itemIdx];
            let pcDiv = `pc_00${i + 1}`;
            let pcCondDiv = `pc_cond_00${i + 1}`;
    
            setup_render_divs_pc(pcDiv, `./models/pc/${item}.ply`);
            setup_render_divs(pcCondDiv, `./models/pc_cond_ply/${item}.ply`);
            
        }
    }

    function nextPage() {
        if (currentPage < totalPages) {
            currentPage++;
            render_page(currentPage);
        }
    }

    function prevPage() {
        if (currentPage > 1) {
            currentPage--;
            render_page(currentPage);
        }
    }
    
    window.onload = function () {
        render_page(currentPage); // 初始渲染第一页
    
        
        let renderContainer = document.getElementById("render-container");
    
      
        let navContainer = document.createElement("div");
    
        navContainer.style.display = "flex";
        navContainer.style.justifyContent = "center";
        navContainer.style.gap = "50px";
        navContainer.style.marginTop = "20px";
       
        navContainer.style.padding = "10px 0";
        //navContainer.style.background = "rgba(255, 255, 255, 0.9)";
        navContainer.style.borderRadius = "8px";
    
        function styleButton(button) {
            button.style.padding = "10px 20px";
            button.style.border = "none";
            button.style.backgroundColor = "#a641c6";
            button.style.color = "white";
            button.style.fontSize = "16px";
            button.style.borderRadius = "5px";
            button.style.cursor = "pointer";
            button.style.transition = "background 0.3s, transform 0.2s";
            button.onmouseover = () => (button.style.backgroundColor = "#68297c");
            button.onmouseout = () => (button.style.backgroundColor = "#a641c6");
            button.onmousedown = () => (button.style.transform = "scale(0.95)");
            button.onmouseup = () => (button.style.transform = "scale(1)");
        }
    
        let prevButton = document.createElement("button");
        prevButton.textContent = "Back";
        prevButton.onclick = prevPage;
        styleButton(prevButton);
    
        let nextButton = document.createElement("button");
        nextButton.textContent = "Next";
        nextButton.onclick = nextPage;
        styleButton(nextButton);
    

    
    
        function updateButtons() {
            prevButton.style.display = currentPage === 1 ? "none" : "block";
            nextButton.style.display = currentPage === totalPages ? "none" : "block";
        }
        
        /*function updateButtons() {
            if (currentPage === 0) {
                prevButton.style.display = "none"; 
            } else {
                prevButton.style.display = "block";
            }

            if (currentPage === totalPages - 1) {
                nextButton.style.display = "none"; 
            } else {
                nextButton.style.display = "block";
            }
        }*/
    
       
        navContainer.appendChild(prevButton);
        //navContainer.appendChild(pageIndicator);
        navContainer.appendChild(nextButton);
    
      
        if (renderContainer) {
            renderContainer.appendChild(navContainer);
            //updatePageIndicator(); // 首次加载时创建指示器
        }
    };


    function create_point_cloud_div(camera, div_id, point_cloud_path) {
        let container;
        let renderer, controls;
    
        init();
        animate();
    
        function init() {
            container = document.getElementById(div_id);
            let width = container.parentElement.clientWidth;
            let height = container.parentElement.clientHeight;
    
            div_to_scene[div_id]["color"] = new THREE.Scene();
            div_to_scene[div_id]["geo"] = new THREE.Scene();
            div_to_scene[div_id]["color"].background = new THREE.Color( 0xffffff );
            div_to_scene[div_id]["geo"].background = new THREE.Color( 0xffffff );

            // PLY file
            const loader = new PLYLoader();
            loader.load( point_cloud_path, function ( geometry ) {
                
                
                const material = new THREE.PointsMaterial({ color: 0x3e2984, size: 0.01 });

                
                const points = new THREE.Points(geometry, material);
                const points2 = new THREE.Points(geometry, material);

                div_to_scene[div_id]["geo"].add( points );
                div_to_scene[div_id]["color"].add( points2 );

            }, (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            }, (error) => {
                console.log('load fail')
                console.log(error)
            }
            );
    
            div_to_scene[div_id]["color"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            div_to_scene[div_id]["geo"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            addShadowedLight(div_to_scene[div_id]["color"], 1, 1, 1, 0xffffff, 1.35 / 2 );
            addShadowedLight(div_to_scene[div_id]["color"],  0.5, 1, - 1, 0xffffff, 1 / 2 );
            addShadowedLight(div_to_scene[div_id]["geo"], 1, 1, 1, 0xffffff, 1.35 );
            addShadowedLight(div_to_scene[div_id]["geo"],  0.5, 1, - 1, 0xffffff, 1 );
    
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;
    
            renderer.shadowMap.enabled = true;
    
            container.appendChild(renderer.domElement);
    
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
    
            // Resize
            window.addEventListener('resize', onWindowResize);
        }
    
        function onWindowResize() {
            let width = container.clientWidth;
            let height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( div_to_scene[div_id][render_colors ? "color" : "geo"], camera );
            controls.update();
        }

        return controls;
    }

   

    function create_render_div(camera, div_id, mesh_path) {
        let container;
        let renderer, controls;

        init();
        animate();

        function init() {

            container = document.getElementById(div_id);
            let width = container.parentElement.clientWidth;
            let height = container.parentElement.clientHeight;

            div_to_scene[div_id]["color"] = new THREE.Scene();
            div_to_scene[div_id]["geo"] = new THREE.Scene();
            div_to_scene[div_id]["color"].background = new THREE.Color( 0xffffff );
            div_to_scene[div_id]["geo"].background = new THREE.Color( 0xffffff );

            // PLY file
            // console.log(mesh_path)
            const loader = new PLYLoader();
            loader.load( mesh_path, function ( geometry ) {
              
                geometry.computeVertexNormals();
                    
                let start_color = new THREE.Color(0.416, 0.106, 0.604); // 紫色
                let end_color = new THREE.Color(1.0, 0.976, 0.769);     // 黄色

              
                let position = geometry.attributes.position;
                let minY = Infinity, maxY = -Infinity;
                for (let i = 0; i < position.count; i++) {
                    let y = position.getY(i);
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                }
                let deltaY = maxY - minY || 1; 
                
                let colors = new Float32Array(position.count * 3);
                for (let i = 0; i < position.count; i++) {
                    let t = (position.getY(i) - minY) / deltaY; 
                    let color = new THREE.Color(
                        start_color.r * (1 - t) + end_color.r * t,
                        start_color.g * (1 - t) + end_color.g * t,
                        start_color.b * (1 - t) + end_color.b * t
                    );
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

               
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                let material_color = new THREE.MeshStandardMaterial({
                    vertexColors: true, 
                    flatShading: true,
                    side: THREE.DoubleSide
                });
                let material_geo = new THREE.MeshStandardMaterial({
                    vertexColors: true, // 启用顶点颜色
                    flatShading: true,
                    side: THREE.DoubleSide
                });

                // let material_color = new THREE.MeshStandardMaterial( { color: 0x4169E1, flatShading: true, side: THREE.DoubleSide } )
                //let material_geo = new THREE.MeshStandardMaterial( { color: 0x2e4e8c, flatShading: true, side: THREE.DoubleSide } )

                let wireframe = new THREE.WireframeGeometry( geometry );
                let line = new THREE.LineSegments( wireframe );
                
                line.material.color.setHex(0x000000);
       
                
               

                const mesh_color = new THREE.Mesh( geometry, material_color );
                const mesh_geo = new THREE.Mesh( geometry, material_geo );

                div_to_scene[div_id]["color"].add( mesh_color );
                div_to_scene[div_id]["color"].add(line);
                div_to_scene[div_id]["geo"].add( mesh_geo );

            }, (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            }, (error) => {
                console.log('load fail')
                console.log(error)
            }
            );

            // lights

            //div_to_scene[div_id]["color"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            //div_to_scene[div_id]["geo"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );

            /*addShadowedLight(div_to_scene[div_id]["color"], 1, 1, 1, 0xffffff, 1.35 / 2 );
            addShadowedLight(div_to_scene[div_id]["color"],  0.5, 1, - 1, 0xffffff, 1 / 2 );
            addShadowedLight(div_to_scene[div_id]["geo"], 1, 1, 1, 0xffffff, 1.35 );
            addShadowedLight(div_to_scene[div_id]["geo"],  0.5, 1, - 1, 0xffffff, 1 );*/
            // 1. 添加环境光（均匀照亮所有面）
            let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            div_to_scene[div_id]["color"].add(ambientLight);
            div_to_scene[div_id]["geo"].add(ambientLight.clone());

            // 2. 添加半球光（让整体光照更自然）
            let hemiLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.6);
            hemiLight.position.set(0, 10, 0);
            div_to_scene[div_id]["color"].add(hemiLight);
            div_to_scene[div_id]["geo"].add(hemiLight.clone());
            

            // renderer

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.shadowMap.enabled = true;

            container.appendChild( renderer.domElement );

            controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = false

            // resize

            window.addEventListener( 'resize', onWindowResize );

    }
        function onWindowResize() {
            let width = container.clientWidth;
            let height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( div_to_scene[div_id][render_colors ? "color" : "geo"], camera );
            controls.update();
        }

        return controls;
    }


    function addShadowedLight(scene, x, y, z, color, intensity ) {
    

    }

    document.addEventListener('keydown', logKey);

    function logKey(evt) {
        if (evt.keyCode === 71 && !mouse_button_down) {
            switch_geometry()
        }
        if (evt.keyCode === 82 && !mouse_button_down) {
            list_of_orbit_controls.forEach(oc => {
                console.log(oc.object.position)
            })
            reset_orbit_controls()
        }
    }

    function switch_geometry() {
        render_colors = !render_colors
    }

    function reset_orbit_controls() {
        list_of_orbit_controls.forEach(oc => {
            oc.reset()
        })
    }

    function set_style_0(){
        style_id = "0"
    }

    function set_style_1(){
        style_id = "1"
    }

    function set_style_2(){
        style_id = "2"
    }

    document.body.onmousedown = function(evt) {
        if (evt.button === 0)
            mouse_button_down = true
    }
    document.body.onmouseup = function(evt) {
        if (evt.button === 0)
            mouse_button_down = false
    }

    

    </script>

    

</body>

</html>
